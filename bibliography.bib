 @inproceedings{Tanimoto_2015,
  place     = {Atlanta, GA, USA},
  title     = {Transparency and liveness in visual programming environments for novices},
  isbn      = {978-1-4673-8367-7},
  url       = {http://ieeexplore.ieee.org/document/7369016/},
  doi       = {10.1109/BLOCKS.2015.7369016},
  booktitle = {2015 IEEE Blocks and Beyond Workshop (Blocks and Beyond)},
  publisher = {IEEE},
  author    = {Tanimoto, Steven L.},
  year      = {2015},
  month     = {Oct},
  pages     = {113–114}
}

 @inproceedings{Tanimoto_2013,
  place     = {San Francisco, CA, USA},
  title     = {A perspective on the evolution of live programming},
  isbn      = {978-1-4673-6265-8},
  url       = {http://ieeexplore.ieee.org/document/6617346/},
  doi       = {10.1109/LIVE.2013.6617346},
  booktitle = {2013 1st International Workshop on Live Programming (LIVE)},
  publisher = {IEEE},
  author    = {Tanimoto, Steven L.},
  year      = {2013},
  month     = {May},
  pages     = {31–34}
}

 @article{Pothier_Tanter_2009,
  title   = {Back to the Future: Omniscient Debugging},
  volume  = {26},
  issn    = {0740-7459},
  doi     = {10.1109/MS.2009.169},
  number  = {6},
  journal = {IEEE Software},
  author  = {Pothier, Guillaume and Tanter, Éric},
  year    = {2009},
  month   = {Nov},
  pages   = {78–85}
}

 @inproceedings{Salvaneschi_Mezini_2016,
  place     = {Austin, Texas},
  title     = {Debugging for reactive programming},
  isbn      = {978-1-4503-3900-1},
  url       = {http://dl.acm.org/citation.cfm?doid=2884781.2884815},
  doi       = {10.1145/2884781.2884815},
  booktitle = {Proceedings of the 38th International Conference on Software Engineering - ICSE ’16},
  publisher = {ACM Press},
  author    = {Salvaneschi, Guido and Mezini, Mira},
  year      = {2016},
  pages     = {796–807}
}

 @article{OCallahan_Jones_Froyd_Huey_Noll_Partush_2017,
  title        = {Engineering Record And Replay For Deployability: Extended Technical Report},
  url          = {http://arxiv.org/abs/1705.05937},
  abstractnote = {The ability to record and replay program executions with low overhead enables many applications, such as reverse-execution debugging, debugging of hard-to-reproduce test failures, and “black box” forensic analysis of failures in deployed systems. Existing record-and-replay approaches limit deployability by recording an entire virtual machine (heavyweight), modifying the OS kernel (adding deployment and maintenance costs), requiring pervasive code instrumentation (imposing significant performance and complexity overhead), or modifying compilers and runtime systems (limiting generality). We investigated whether it is possible to build a practical record-and-replay system avoiding all these issues. The answer turns out to be yes - if the CPU and operating system meet certain non-obvious constraints. Fortunately modern Intel CPUs, Linux kernels and user-space frameworks do meet these constraints, although this has only become true recently. With some novel optimizations, our system ‘rr’ records and replays real-world low-parallelism workloads with low overhead, with an entirely user-space implementation, using stock hardware, compilers, runtimes and operating systems. “rr” forms the basis of an open-source reverse-execution debugger seeing significant use in practice. We present the design and implementation of ‘rr’, describe its performance on a variety of workloads, and identify constraints on hardware and operating system design required to support our approach.},
  note         = {arXiv: 1705.05937},
  journal      = {arXiv:1705.05937 [cs]},
  author       = {O’Callahan, Robert and Jones, Chris and Froyd, Nathan and Huey, Kyle and Noll, Albert and Partush, Nimrod},
  year         = {2017},
  month        = {May}
}

 @inproceedings{Alabor_Stolze_2020,
  place        = {New York, NY, USA},
  series       = {REBLS 2020},
  title        = {Debugging of RxJS-Based Applications},
  isbn         = {978-1-4503-8188-8},
  url          = {https://doi.org/10.1145/3427763.3428313},
  doi          = {10.1145/3427763.3428313},
  abstractnote = {RxJS is a popular library to implement data-flow-oriented applications with JavaScript using reactive programming principles. This way of programming bears new challenges for traditional debuggers: Their focus on imperative programming limits their applicability to problems originated in the declarative programming paradigm. The goals of this paper are: (i) to understand how software engineers debug RxJS-based applications, what tools do they use, what techniques they apply; (ii) to understand what are the most prevalent challenges they face while doing so; and (iii) to provide a course of action to resolve these challenges in a future iteration on the topic. We learned about the debugging habits of ten professionals using interviews, and hands-on war story reports. Based on this data, we designed and executed an observational study with four subjects to verify that engineers predominantly augment source code with manual trace logs instead of using specialized debugging utilities. In the end, we identified the lack of fully integrated RxJS-specific debugging solutions in existing development environments as the most significant reason why engineers do not make use of such tools. We decided to elaborate on how to resolve this situation in our future work.},
  note         = {event-place: Virtual, USA},
  booktitle    = {Proceedings of the 7th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems},
  publisher    = {Association for Computing Machinery},
  author       = {Alabor, Manuel and Stolze, Markus},
  year         = {2020},
  pages        = {15–24},
  collection   = {REBLS 2020}
}

 @misc{Alabor_2020,
  title        = {User Journey: Debugging of RxJS-Based Applications},
  url          = {https://alabor.me/research/user-journey-debugging-of-rxjs-based-applications/},
  abstractnote = {This document describes two user journeys of Frank Flow, a software engineer working on an application implemented using RxJS. The application has a web-based user interface and was part of a study by Alabor et al. Frank will use different debugging techniques and utilities to solve the task given to him. The journeys follow the debugging process model proposed by Layman et al.},
  author       = {Alabor, Manuel},
  year         = {2020},
  month        = {Dec}
}

 @inproceedings{McDirmid_2013,
  place     = {Indianapolis, Indiana, USA},
  title     = {Usable live programming},
  isbn      = {978-1-4503-2472-4},
  url       = {http://dl.acm.org/citation.cfm?doid=2509578.2509585},
  doi       = {10.1145/2509578.2509585},
  booktitle = {Proceedings of the 2013 ACM international symposium on New ideas, new paradigms, and reflections on programming & software - Onward! ’13},
  publisher = {ACM Press},
  author    = {McDirmid, Sean},
  year      = {2013},
  pages     = {53–62}
}

 @inproceedings{Salvaneschi_Mezini_2016,
  place     = {Austin, Texas},
  title     = {Debugging reactive programming with reactive inspector},
  isbn      = {978-1-4503-4205-6},
  url       = {http://dl.acm.org/citation.cfm?doid=2889160.2893174},
  doi       = {10.1145/2889160.2893174},
  booktitle = {Proceedings of the 38th International Conference on Software Engineering Companion - ICSE ’16},
  publisher = {ACM Press},
  author    = {Salvaneschi, Guido and Mezini, Mira},
  year      = {2016},
  pages     = {728–730}
}

 @inproceedings{Banken_Meijer_Gousios_2018,
  place     = {Gothenburg Sweden},
  title     = {Debugging data flows in reactive programs},
  isbn      = {978-1-4503-5638-1},
  url       = {https://dl.acm.org/doi/10.1145/3180155.3180156},
  doi       = {10.1145/3180155.3180156},
  booktitle = {Proceedings of the 40th International Conference on Software Engineering},
  publisher = {ACM},
  author    = {Banken, Herman and Meijer, Erik and Gousios, Georgios},
  year      = {2018},
  month     = {May},
  pages     = {752–763}
}
